using System;
using System.CodeDom;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using Localization.Core;

namespace Localization.iOS
{
	public class LocalizationIOSTask : BaseLocalizationTask
	{
		protected override void GenerateForDirectory(string directory, Dictionary<string, string> keyValues)
		{
			string outputFile = Path.Combine(directory, "Localizable.strings");
			if (keyValues.Count == 0) //ios could not handle empty Localizable.strings file so add a default one if none are present
			{
				keyValues["Library"] = "Storm.CrossLocalization";
			}

			FileHelper.WriteIfDifferent(outputFile, keyValues.Select(x => $"\"{x.Key}\" = \"{x.Value}\";"));
			OutputResourceFilePath.Add(outputFile);
			
			base.GenerateForDirectory(directory, keyValues);
		}

		protected override void GenerateForProject(List<string> keys)
		{
			GenerateLocalizationService(keys);
			GenerateLocalizedStrings(keys);
			
			base.GenerateForProject(keys);
		}

		protected override string ProcessValue(string value)
		{
			return value?.Replace("\\", "\\\\")
					.Replace("\"", "\\\"")
					.Replace("\n", "\\n")
				;
		}

		protected override bool IsCurrentPlatformKey(string key) => key.IsIosString();

		protected virtual void GenerateLocalizationService(List<string> keys)
		{
			CodeCompileUnit codeUnit = new CodeCompileUnit();

			// for class declaration
			CodeNamespace codeNamespace = new CodeNamespace(GenerationNamespace);
			codeUnit.Namespaces.Add(codeNamespace);

			codeNamespace.Imports.Add(new CodeNamespaceImport("System"));
			codeNamespace.Imports.Add(new CodeNamespaceImport("Foundation"));

			// create class
			CodeTypeDeclaration classDeclaration = new CodeTypeDeclaration(Constants.IMPLEMENTATION_SERVICE_NAME)
			{
				IsClass = true,
				TypeAttributes = TypeAttributes.Public,
			};
			classDeclaration.BaseTypes.Add(Constants.INTERFACE_SERVICE_NAME);
			codeNamespace.Types.Add(classDeclaration);
			
			//methode
			var method = new CodeMemberMethod
			{
				Name = Constants.SERVICE_METHOD_NAME,
				ReturnType = new CodeTypeReference(typeof(string)),
				Attributes = MemberAttributes.Public
			};
			method.Parameters.Add(new CodeParameterDeclarationExpression(Constants.ENUM_NAME, "key"));
			classDeclaration.Members.Add(method);

			CodeVariableReferenceExpression methodParam = new CodeVariableReferenceExpression("key");
			CodeMethodReferenceExpression localizedStringsMethodReference = new CodeMethodReferenceExpression(new CodePropertyReferenceExpression(new CodeTypeReferenceExpression("NSBundle"), "MainBundle"), "LocalizedString");

			foreach (string key in keys)
			{
				CodeConditionStatement condition = new CodeConditionStatement(
					new CodeBinaryOperatorExpression(
						methodParam,
						CodeBinaryOperatorType.IdentityEquality,
						new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(Constants.ENUM_NAME), key)
						),
					new CodeMethodReturnStatement(
						new CodeMethodInvokeExpression(localizedStringsMethodReference, new CodePrimitiveExpression(key), new CodePrimitiveExpression(null))
						)
					);

				method.Statements.Add(condition);
			}

			method.Statements.Add(new CodeThrowExceptionStatement(new CodeObjectCreateExpression(typeof(ArgumentOutOfRangeException))));

			codeUnit.WriteToFile(Constants.IMPLEMENTATION_SERVICE_FILE_PATH, "This file was generated by Localization task for iOS");
			OutputCompileFilePath.Add(Constants.IMPLEMENTATION_SERVICE_FILE_PATH);
		}

		protected virtual void GenerateLocalizedStrings(List<string> keys)
		{
			CodeCompileUnit codeUnit = new CodeCompileUnit();

			// for class declaration
			CodeNamespace codeNamespace = new CodeNamespace(GenerationNamespace);
			codeUnit.Namespaces.Add(codeNamespace);

			codeNamespace.Imports.Add(new CodeNamespaceImport("System"));
			codeNamespace.Imports.Add(new CodeNamespaceImport("Foundation"));

			// create class
			CodeTypeDeclaration classDeclaration = new CodeTypeDeclaration(Constants.LOCALIZED_STRINGS_NAME)
			{
				IsClass = true,
				TypeAttributes = TypeAttributes.Public | TypeAttributes.Sealed,
			};
			codeNamespace.Types.Add(classDeclaration);
			
			//constructor
			CodeConstructor constructor = new CodeConstructor
			{
				Attributes = MemberAttributes.Private
			};
			classDeclaration.Members.Add(constructor);
			
			CodeMethodReferenceExpression localizedStringsMethodReference = new CodeMethodReferenceExpression(new CodePropertyReferenceExpression(new CodeTypeReferenceExpression("NSBundle"), "MainBundle"), "LocalizedString");

			foreach (string key in keys)
			{
				CodeMemberProperty property = new CodeMemberProperty
				{
					Name = key,
					Type = new CodeTypeReference(typeof(string)),
					Attributes = MemberAttributes.Public | MemberAttributes.Static
				};

				property.GetStatements.Add(new CodeMethodReturnStatement(
					new CodeMethodInvokeExpression(localizedStringsMethodReference, new CodePrimitiveExpression(key), new CodePrimitiveExpression(null))
					));
				classDeclaration.Members.Add(property);
			}
			
			codeUnit.WriteToFile(Constants.LOCALIZED_STRINGS_FILE_PATH, "This file was generated by Localization task for iOS");
			OutputCompileFilePath.Add(Constants.LOCALIZED_STRINGS_FILE_PATH);
		}
	}
}
